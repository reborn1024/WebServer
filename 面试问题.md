# 面试被问过的问题
1. 介绍一下这个项目（几乎是必问的）。  

    这个项目是一个基于C++11开发的Web服务器，它采用了Epoll的边沿触发模式进行IO多路复用，并结合非阻塞IO以及Reactor设计模式来处理网络事件。主要特点包括使用了多线程来充分利用多核CPU资源，并通过线程池技术减少了线程频繁创建和销毁的性能开销。
      
    项目中还实现了基于小根堆的定时器，以关闭超时请求，并且服务器的主线程仅负责接收新的连接请求，然后以轮询方式将其分配给其他IO线程进行处理，从而降低锁争用。此外，为了唤醒阻塞在Epoll调用的工作线程，项目使用了eventfd机制。
      
    日志系统采用双缓冲区技术以达到异步记录日志的效果，减少了对IO线程的影响。服务器还支持HTTP长连接、管线化处理请求，并可以优雅地关闭连接。整体上，项目旨在提供一个高性能、高并发的Web服务解决方案。  

2. 定时器是怎么实现的？还有什么实现方式？

    本项目中的定时器是通过小根堆实现的，每个SubReactor都持有一个定时器，其中存储了所有待处理定时事件。小根堆的顶部总是最早到期的事件，这样检查和删除超时事件就非常高效。定时器采取惰性删除策略，即只有在事件循环的最后才检查和删除超时事件，这样做虽然对时间精度要求不高，但可以减少不必要的时间管理操作。

    除了小根堆实现，还有其他的定时器实现方式：

    1. 时间轮：适用于处理大量的具有相对过期时间的定时事件。
    2. stl的set/multiset：通过红黑树实现，插入和删除操作为O(log n)，但通常比小根堆慢。
    3. Linux内核提供的timerfd：可以作为epoll事件来处理，与IO事件统一管理

3. 实现一个无锁队列（用原子操作）。
4. eventfd是什么？有什么好处？

    eventfd 是 Linux 系统提供的一个系统调用，它创建了一个用于事件通知的文件描述符。eventfd 生成的文件描述符可以被用来在用户空间应用程序与内核或不同的线程之间进行高效的通信。

    好处：

        原子操作: eventfd 支持对计数器的增减操作，这些操作是原子的，因此在多线程环境中不需要额外的同步机制。
        轻量级: 它不需要创建管道（pipe）或者信号量等传统的 IPC 机制，从而避免了额外的开销。
        可用于epoll: eventfd 创建的文件描述符可以加入到 epoll 实例中进行监控，当状态变更时可以通过 epoll 高效地被唤醒或通知。
        避免竞态条件: 由于 eventfd 可以整合进 epoll 的事件循环中，可以避免使用条件变量或其他传统同步机制可能出现的竞态条件问题。

5. 双缓冲区异步日志是什么？为什么要这样做？对这个日志系统有没有进行压力测试？

    * 日志库分为前端和后端两个部分，前端用于生成日志消息并传送到后端，后端则负责将日志消息写入本地日志文件。
    * 应用程序是生产者通过 Logging 接口进行日志的生成，包括自动捕获的上下文信息如时间戳，类内含一个LogStream对象，LogStream主要用来格式化输出，重载了<<运算符，支持连续的输入并且在内部维护一个小的缓冲区，在前端这个类析构时会调用后端的append方法，放入后端缓冲区。
    * 后端的AsyncLogging是消费者，使用单例设计，它负责启动一个后台线程，负责(定时到或被填满时)将缓冲区中的数据写入日志文件中。应用了“双缓冲技术”，具体来说，后端有一个当前缓存区和备用缓冲区，当前缓存区满了，就将当前缓存区放到待落盘缓存区队列，将备用缓存区移动到当前缓存区，唤醒后台线程，在后台线程，因而被唤醒，或者定时唤醒取走当前缓存区，交换待落盘缓存区队列和正在落盘缓存区队列，将正在落盘缓存区队列数据写入日志。

6. 什么是优雅关闭连接？（就是read()到0，要透明的传递这个行为而不是直接暴力close()）。

    优雅关闭连接指的是在传输完所有待发送数据之后再关闭TCP连接的过程。在TCP/IP网络编程中，当read()函数返回0，表示对方已经关闭了连接（发送了FIN包）。在这种情况下，程序应该优雅地处理关闭过程，即先完成所有的数据处理工作，然后再关闭自己这一端的连接，而不是直接调用close()函数粗暴地关闭socket。优雅关闭连接有助于确保数据的完整性和防止出现例如TIME_WAIT状态过多等问题。

7. epoll的边沿触发和水平触发有什么区别？（epoll的源码并不长，从源码的角度回答比较好）。

    epoll支持两种触发模式：水平触发（Level Triggered, LT）和边沿触发（Edge Triggered, ET）。这两种模式定义了内核如何向用户通知就绪的文件描述符。

        水平触发（LT）：只要被监视的文件描述符处于就绪状态，内核就会通知该事件，无论之前是否已经通知过。这意味着如果数据可读，但应用程序没有读取，内核会持续报告可读事件。

        边沿触发（ET）：内核仅在被监视的文件描述符状态发生变化时通知一次事件，例如从未就绪变为就绪。如果应用程序没有一次性处理完所有数据（比如读到EAGAIN），那么即使数据仍然可读，内核也不会再通知该事件。

    ET模式相比于LT模式能够减少事件的触发次数，提高效率，特别是在高负载的场景下。然而，ET模式要求应用程序必须更加谨慎地处理IO，确保一次性处理完所有的数据，否则可能会错过某些情况。

    在源码层面，epoll是基于红黑树来存储所有的fd，并使用一个链表来记录就绪的事件。在ET模式下，当epoll_wait检测到某个fd状态变化时，它会将这个事件添加到就绪列表中，并且不会重复插入；而在LT模式下，只要fd还在就绪状态，它就可以在以后的epoll_wait调用中被重新报告。

8. epoll为什么高效，相比select和poll？

    - 扩展性: epoll 可以轻松处理数千甚至更多的并发连接，而 select 和 poll 由于其设计限制，在连接数目较大时性能显著下降。
    - 无需重复扫描: 在 select 和 poll 中，每次调用都需要重新传入完整的监听列表，并且内核需要遍历整个列表来检查哪些文件描述符就绪，这样随着文件描述符数量增长，效率线性下降。而 epoll 通过一次注册后只对活跃的文件描述符采取回调机制，省去了不必要的重复遍历。
    - 事件驱动: epoll 是基于事件的，只有活跃的文件描述符才会导致系统调用返回，内核使用事件通知的方式告诉应用程序哪些文件描述符已经就绪，减少了无谓的检查和等待。
    - 边缘触发: epoll 支持边缘触发（ET）模式，这意味着只有状态变化才会通知，进一步降低了事件处理的频率，而 select 和 poll 默认是水平触发（LT），状态没有改变也会通知。

9. HTTP报文都有哪些字段？

    请求报文:

        请求行: 包含方法（GET, POST等）、请求资源的路径、HTTP版本。
        请求头部: 包含客户端环境信息、请求体大小等，常见的头部字段包括 Host, User-Agent, Accept, Connection, Content-Type, Content-Length 等。
        空行: 代表头部结束。
        请求体: 包含发送给服务器的数据，不是所有的请求都有请求体（例如GET请求）。
        

    响应报文:

        状态行: 包含HTTP版本、状态码（如200表示成功）、状态文本。
        响应头部: 包含服务器信息、内容类型和长度等，常见的头部字段包括 Server, Content-Type, Content-Length, Connection, Set-Cookie 等。
        空行: 代表头部结束。
        响应体: 包含服务器返回给客户端的数据。

10. 假如服务器要升级，又不想让用户感觉到服务器升级了，该怎么做？（其实就是不间断的提供服务，参考nginx的平滑升级）。

    - 启动新版本的程序: 启动新版本的服务程序但监听不同的端口或者使用不同的系统资源。
    - 测试新版本: 确保新版本正常工作，所有特性和配置均已正确无误。
    - 热切换（Graceful Switch）: 将正在使用的资源（如监听的端口、文件描述符）转移给新版本的程序。在nginx中，这涉及向旧的 master 进程发送信号，将打开的监听套接字传递给新的 master 进程。
    - 逐渐停止老版本: 新的连接由新版本处理，同时旧版本等待当前连接关闭。待所有旧连接都处理完毕后，再完全停止旧版本的服务。
    - 监控: 在升级后的一段时间内密集地监控系统，确保一切正常运行，并准备回滚计划以防万一新版本出现重大问题。

11. 有没有实现内存池？
12. 一个请求到来具体的处理过程是怎样的？

    当一个请求到达时，主线程的MainReactor接收连接请求并建立连接，然后使用Round Robin算法将新连接分配给一个SubReactor。 分配操作涉及跨线程任务，因此需要加锁。新连接加入到SubReactor的epoll监听队列中。当IO事件触发，对应线程会通过eventfd被唤醒，处理事件（如读取数据、解析HTTP请求等），并执行相应的回调函数完成请求的响应。

13. 线程的唤醒还有哪些方式？

    pthread_cond_signal 或 pthread_cond_broadcast 使用条件变量；
    sem_post 使用信号量；
    管道（pipe）或者套接字对（socketpair），写入数据以触发可读事件；

14. 怎么检查内存泄漏的？
15. 用到了哪些智能指针和RAII机制，几种锁的区别是什么？

    文档中提到使用了智能指针等RAII机制，但没有具体说明使用了哪些智能指针。C++11中常见的智能指针包括std::unique_ptr、std::shared_ptr和std::weak_ptr。RAII机制通常利用对象生命周期自动管理资源，比如自动释放内存、关闭文件句柄等。

    几种锁的区别通常有：

        互斥锁（Mutex）：基本的排他锁，同一时间只有一个线程可以持有锁。
        自旋锁（Spinlock）：忙等待锁，在等待锁的释放期间不断轮询而不是休眠。
        读写锁（RW lock）：允许多个线程同时读取，但写入时需独占。
        递归锁（Recursive mutex）：允许同一个线程多次获取锁，防止死锁情况。

16. 任务队列是怎么实现的，除了加锁还有什么方式？

    通常任务队列会采用互斥锁保护共享资源。无锁队列可以使用原子操作保证线程安全，避免了加锁的开销。

17. 如何解决死锁？
18. 怎么进行压测的？
19. 为什么要用非阻塞io？
20. 为什么要做这个项目？

    做Web服务器项目有助于深入理解HTTP协议、网络IO模型、并发编程等计算机网络和系统编程的核心知识。此外，这也是展示编程能力、解决复杂问题能力的一个很好的实践，尤其对于准备面试或者提升技术水平的开发者来说。

21. Reactor模式是什么？

    Reactor模式是一种事件驱动的设计模式，用于处理服务请求的分发。在这个模式下，Reactor对象负责监控和分发事件，即它等待事件的发生并且分发给相应的处理器进行非阻塞处理。这样做可以很容易的在单个进程内并发处理多个输入输出事件，大大提高了程序的处理效率。